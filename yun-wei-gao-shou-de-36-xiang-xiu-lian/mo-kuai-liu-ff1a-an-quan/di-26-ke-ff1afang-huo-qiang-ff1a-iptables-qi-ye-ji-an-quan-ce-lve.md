# 第26课：防火墙：iptables 企业级安全策略

本课时我们来学习安全模块：iptables 企业级安全策略。

## 什么是 iptables

说到 iptables，如果你用过 Linux 会比较了解，它是 Linux 上的一套防火墙服务，调用的其实是 Netfilter 内核模块。Netfilter 是 Linux 操作系统核心层内部的一个数据包处理模块，它具有如下功能：
1.网络地址转换；
2.数据包内容修改；
3.数据包过滤防火墙功能。

在现实中，其实很多应用服务都调用了 Netfilter。这里我给你画了一张图：

CgqCHl7GXLmAQNIJAAAx_JTgoQQ756.png

可以看到，在最中央就是 Netfilter 的 Linux 内核模块了，我们看到最下层 iptables 会调用 Netfilter 模块来作为安全防火墙。在 CentOS7 以后，出来一款新的防火墙服务叫作 firewalld，其实也是调用了 Netfilter 模块。总体来说，无论是 iptables，还是 firewalld，它们都是调用了 Linux 的 Netfilter 内核模块。

我们再来看图片左边，这里有一个 ipvs 应用工具，它也调用了 Netfilter，但是它的功能和安全防护的防火墙功能有一些区别，它主要用来实现地址转换这样的一个核心功能，所以 ipvs 会为很多负载均衡提供服务，也就是为 LVS 提供服务，如果你了解过 LVS 就会清楚，其实 LVS 就是用到了 ipvs 的命令模块来对数据包规则进行设置。所以 ipvs 的上一层会供 LVS 调用，它在运维管理中可以作为防火墙服务来使用。所以我们会看到 ipvs 是作为负载均衡的服务来使用的，可以总结为负载均衡的服务其实也是调用了 Netfilter 内核模块。

除此之外，我们在这张图的左下角还会看到一个 Kube-proxy 命令模块，它也调用了 ipvs，同时也调用 iptables。其实 Kube-proxy 是 K8s 里的一个组件，负责管理 K8s 里的 service 模块，也就是后端服务，管理后端服务需要对数据包进行转发，并实现负载均衡。我们会看到在 K8s 整套模块的组件里，Kube-proxy 其实也调用了 ipvs，同时基于 ipvs 去调用 Linux 内核的 Netfilter，那么为什么 Kube-proxy 还要去调用 iptables？这是因为早期的 Kube-proxy 版本是基于 iptables 实现的，但是这里有一个性能问题，因为 iptables 毕竟不是专门用作数据包转发的，所以在 service 高于 1000 个的情况下，性能表现上 ipvs 优于 iptables。所以就逐渐使用了 ipvs 服务来代替 iptables 工具。

在这张图里，我们会看到当前整个 Netfilter 在应用平台服务里面，起到的至关性作用。而 iptables 发布的其实是两款专业的防火墙工具，那么对于 iptables 和 firewalld，这两个防火墙服务之间有两个比较大的差异，这里给你来介绍一下。


## iptables 和 firewalld 之间的差异

iptables 默认是允许访问服务或者通过数据包进行访问的，如果我们不允许某些数据包访问，就可以设置具体的规则去进行阻断。firewalld 则是默认拒绝所有数据包进行访问，只有我们允许一个数据包满足某个规则的时候，才去做对应的设置。所以说它们是相反的两个默认设置的防火墙规则。

另外就是 firewalld 在对数据安全的防护管理上用到了区域的概念，会把xxx分成很多个区域来进行安全管理，而 iptables 则不会分区，而是直接基于面的方式去进行规则上的设置。本课时我们重点介绍公司层面的安全，并且通过 iptables 来介绍企业对防火墙的规则设置。

## iptables 企业安全规则

在学习本课时之前，我们先要搞懂 iptables 的一些基础知识，iptables 有一个很重要的设置概念就是 4 表 5 链，我们可以理解为是将一些对数据包设置的不同维度共同组合起来，进行数据包安全功能上的一些具体设置。

有如下的 4 张表，包括一个 Filter 表，一个 NAT 表，一个 Mangle 表，一个 Raw 表。它们分别作用于不同的方向，Filter 表用于过滤数据包（默认表），NAT 表用于网络地址转换（IP、端口），Mangle 表用于修改数据包的服务类型、TTL，并且可以配置路由实现 QOS；Raw 表用于决定数据包是否被状态跟踪机制处理。

5 链分别是 INPUT 链，OUTPUT 链，FORWARD 链，PREROUTING 链和 POSTROUTING 链。这 5 条链分别也对应不同的一些设置规则。

* INPUT 链：进来的数据包应用此规则链中的规则；
* OUTPUT 链：外出的数据包应用此规则链中的规则；
* FORWARD 链：转发数据包时应用此规则链中的规则；
* PREROUTING 链：对数据包作路由选择前应用此链中的规则；
* POSTROUTING 链：对数据包作路由选择后应用此链中的规则。


我们可以认为有了表和链共同的组合，才完成了完整的数据包规则设置。通常一个数据包也需要经过对应表中不同链结合起来的规则，从而完成整个流程的处理。

另外需要特别提及的一个地方是自定义链，它跟我们刚刚讲到的 4 表 5 链相比有一个较特殊的地方，它是为用户方便管理而使用的，它并不会被直接使用，而是需要通过被默认的链引用才能使用。我们可以理解为它是用户指定给设置的一个规则链的名称，用于方便进行整体规则上的设置。接下来本课时将为你演示安全防控规则的设置，这通常是通过 iptables 的 Filter 表结合 INPUT 链规则进行设置，我们来看一看通过这样的一种设置方式可以实现哪些 4 层安全上面的功能设置。

## iptables 命令规则设置的常见选项
那么说到了 iptables 的规则设置，你可能需要了解，通过 iptables 命令进行安全防护规则设置都有哪些选项，下面逐一为你列举了几个具体的一些常见的选项：
Ciqc1F7GXNaAWc-BAACVfKp2FC8903.png

* -A 指向指定链添加一个或多个新规则；
* -D 表示从指定链中删除一个或多个规则；
* -N 表示创建一个新的用户定义链；
* -F 通常是在表初始化时，指定规则链中或所有规则链中的策略；
* -X 则是删除指定的用户定义链（需先清空链路中的策略）；
* -p 指定具体一些协议，比如 TCP、UDP、ICMP 等常见的一些协议数据包；
* -s 用来指定 IP 地址 [/ mask] 源地址；
* -d 用来指定 IP 地址 [/ mask] 目标地址；
* -i 指定设备数据包进入的接口，如果是多网卡的话，可能需要指定具体的接口。

这些对应的选项是你需要提前知道的，如果你不了解的话，建议先看一些 iptables 的基础使用规则，然后再学习后面的部分，否则可能会遇到一些小的问题。

接下来，我们用一些场景来给你讲一讲，在 iptables 里面一些常见的设置安全规则的方式。

第一个模块就是对 iptables 进行初始化，所谓 iptables 初始化就是需要将 iptables 的规则清空，同时又要设置一个默认规则。通常我们需要把规则中的策略进行清空。

* -X 表示是指定用户自定义链来进行删除；
* -Z 则是将指定链路或者策略中的计数归零。

这样的话就完成了整体规则的清空。另外，iptables -P 设置了 3 条具体规则的链，一个是 INPUT 链，一个是 OUTPUT 链，一个是 FORWARD 链。那么这 3 条链分别设置 Accept，也就是允许所有数据包进行访问，这就完成了整体的初始化。我们看到初始化里没有做任何安全防护规则，而是把以往的规则进行清空，并且设置一条权限比较大的规则，在这个基础上再进行具体的安全防护规则设置。

首先第一个安全防护规则就是通过 iptables 命令来进行设置的，每次设置完具体的命令后，就会把这些命令转化为 iptables 所能识别的一条规则生成到配置文件里。通常对于用户来说对配置文件的管理可能是非常容易理解的，所以为了方便进行 iptables 设置，我们更愿意把 iptables 命令的使用和选项的使用，封装成一些 Shell 脚本来直接批量化设置。这里会看到我使用的 iptables 命令进行设置的同时，也结合了一些 Shell 脚本的语法格式。我们来看一下：



```
iptables -A INPUT -i lo -j ACCEPT  //允许本地访问
LOCAL_NET="xxx.xxx.xxx.xxx/xx”  //允许内部指定网段访问
if [ "$LOCAL_NET" ]
then
        iptables -A INPUT -p tcp -s $LOCAL_NET -j ACCEPT
fi
ALLOW_HOSTS=(                             //允许访问主机Ip开白
       "xxx.xxx.xxx.xxx"
       "xxx.xxx.xxx.xxx"
)

if [ "${ALLOW_HOSTS}" ]
then
        for allow_host in ${ALLOW_HOSTS[@]}
        do
                iptables -A INPUT -p tcp -s $allow_host -j ACCEPT
        done
fi

```
首先在前面我们会看到有一个 -A，表示对 INPUT 这一条链以及 -i（本地回放网卡）允许访问，也就是对允许访问本机规则默认开放。在下面有一个 LOCAL_NET，这里其实是定义了一个 Shell 变量，在这个变量里我们可以进行一些自定义配置，比如本地的网络段属于哪一个网站。如果允许本地网络段进行访问，就需要定义一整串网段信息，并且把网段信息复制给 LOCAL_NET，然后判断这个变量是否存在。如果存在的话，则允许本地的网络访问 iptables -A INPUT，-p tcp 表示 TCP 协议， -s 表示原地址，也就是允许所有本地网络原地址来访问这台主机。
下面同样也是白名单设置 Shell 的实施方式：
